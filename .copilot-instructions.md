# GitHub Copilot Chat Instructions for SuaviUI

## Purpose
These instructions guide GitHub Copilot Chat interactions when contributing to the SuaviUI World of Warcraft addon project.

---

## Knowledge Base

### Project Documentation
- **Location:** `/docs/` folder with organized structure
- **Key Documents:**
  - `docs/README.md` - Main addon documentation
  - `docs/CHANGELOG.md` - Release history and version notes
  - `docs/INDEX.md` - Documentation roadmap and file organization
  - `docs/RELEASE_PROCESS.md` - Complete automated release workflow (commit, tag, push, ZIP, publish)
  - `docs/DEVELOPMENT_PRINCIPLES.md` - Coding standards and architecture guidelines
  - `docs/REFERENCES/LIBRARY_AUDIT.md` - Library versions and management
  - `docs/REFERENCES/SETTINGS_SAVE_SYSTEM.md` - Settings persistence mechanism
  - `docs/GUIDES/` - Implementation guides and design documents
  - `docs/ARCHIVE/` - Historical development documentation (WoW API changes, technical analysis from past work)
- **Usage:** Always check these documents for compatibility information and established workflows. Refer to `docs/INDEX.md` for full documentation map.

### Debug Tools
- **Castbar Edit Mode Debug Window:**
  - **NEVER use print() for castbar Edit Mode debugging** - use the dedicated debug window instead
  - **Access:** `/suicbeditmode` command opens the debug window with event log viewer
  - **Logging API:** `CB_EditMode:LogDebug(message)` and `CB_EditMode:ReportDebug(message)` to log to the window
  - **Purpose:** Tracks OnPositionChanged callbacks, LEM integration, position persistence debugging
  - **Location:** Implementation in `utils/castbar_editmode.lua` (CreateDebugWindow, ShowDebugStatus functions)
  - **When to use:** Any debugging related to castbar dragging, position persistence, Edit Mode integration

- **Error Logging & BugSack:**
  - **Primary Error Log:** BugSack SavedVariables file
    - **Location:** `E:\Games\World of Warcraft\_retail_\WTF\Account\SYSELA\SavedVariables\BugSack.lua`
    - **Purpose:** Captures all Lua errors and taint warnings during gameplay
    - **When user says "read the log" or "read the error log":** Check this file FIRST unless they explicitly mention `error.log`
  - **Manual Error Log:** `error.log` (in addon root)
    - **Purpose:** User manually copies error messages here for discussion
    - **When to use:** Only when user explicitly says "read error.log" or references the file directly
  - **Default Behavior:** Always check BugSack SavedVariables for current errors before suggesting fixes

### Project Structure
- **Addon Files:** `/utils/` - Main addon functionality (sui_*.lua files)
- **UI Skinning:** `/skinning/` - Visual customization for WoW UI elements
- **Libraries:** `/libs/` - Ace3 and other dependencies
- **Localization:** `/Locales/` - Multi-language support files
- **Configuration:** `SuaviUI.toc` - Addon manifest file

### Key Technologies
- **Language:** Lua (World of Warcraft scripting)
- **Framework:** Ace3 (AceAddon, AceDB, AceConsole, AceEvent, AceLocale)
- **Libraries:** LibSerialize, LibDeflate, LibCustomGlow, LibKeyBound, etc.

---

## Code Quality Requirements

### Code Modification Rules (Project-Adapted)
1. **Read Before Write**: Always read the specific lines you plan to edit immediately before applying changes to avoid overwriting unseen updates.
2. **Verify After Edit**: After modifying code, validate for regressions via Lua syntax checks (if available) and in-game testing. At minimum, do a `/reload` and confirm no UI errors in-game.
3. **Atomic Changes**: Prefer a single comprehensive edit per file rather than multiple disjoint edits to prevent line-drift and merge issues.
4. **Context Preservation**: When using `replace_string_in_file`, include 3‚Äì5 lines of unchanged context around the change (enough to uniquely identify the section, but not excessive).
5. **EditMode Safety**: If changes impact EditMode, verify drag behavior in EditMode to ensure no nil-rect crashes or snap preview errors.
6. **Release Packaging Awareness**: Release zips must have a top-level folder named exactly `SuaviUI/` for WowUp compatibility.
7. **NEVER Modify External Library Code**: 
   - **DO NOT** edit files in `/libs/` directly (Ace3, LibOpenRaid, LibStub, etc.)
   - **Instead:** Create wrapper/patch files in `/libs/LibraryName_Patches.lua` if fixes are needed
   - **Use hooks/wrapping:** Override functions via SecureHook or function wrapping patterns
   - **Keep libraries pristine:** This allows updating to latest upstream versions without conflicts
   - **Document patches:** If creating wrappers, document why in `SUAVIUI_PATCHES.md` within the library folder
   - **Rationale:** Direct library modifications prevent updates, create maintenance debt, and obscure attribution

### Verification
Before suggesting or implementing changes:
1. **Compatibility Check** - Verify changes don't break existing functionality
2. **WoW API Validation** - Check `/docs/` for any API changes that might affect the code
3. **Lua Syntax** - Ensure all Lua code follows proper syntax
4. **Dependencies** - Confirm all required libraries are available
5. **Test Scenarios** - Consider edge cases and user scenarios

### Implementation Discipline: NEVER RUSH

#### Critical Rule: Read Reference Implementation FIRST
**When told to match another addon's implementation (e.g., "use Sensei implementation"):**
1. **STOP** - Do not write any code yet
2. **LOCATE** - Find the actual reference files in the workspace (e.g., check if SenseiClassResourceBar exists in AddOns folder)
3. **READ COMPREHENSIVELY** - Study the COMPLETE implementation, not just snippets:
   - **Find the entry point** - Where does execution start? (e.g., LEMSettingsLoader.lua, SenseiClassResourceBar.lua)
   - **Trace data flow** - How does data move from settings to display?
     - Settings `set()` callback ‚Üí Database write ‚Üí Method call ‚Üí Visual update
   - **Map all methods** - List every method referenced:
     - ApplyLayout, GetSize, GetPoint, Apply*Settings, UpdateDisplay, etc.
     - For EACH method, read its COMPLETE implementation
   - **Document dependencies** - What helper functions/tables are used?
     - addonTable.resolveRelativeFrames, addonTable.availableRelativeFrames, etc.
   - **Note ALL field names** - Exact property names in database and settings:
     - `minValue` not `min`, `useOldStyle` not `oldStyle`, `generator` not `values` for functions
   - **Understand the architecture** - How components connect:
     - Mixin hierarchy, event flow, callback patterns
4. **CREATE IMPLEMENTATION MAP** - Before writing code, document:
   ```
   Reference Implementation Analysis:
   ================================
   
   Entry Points:
   - File: LEMSettingsLoader.lua, Function: BuildLemSettings()
   
   Data Flow:
   1. User changes setting in Edit Mode panel
   2. Setting's set(layoutName, value) called
   3. Database updated: SenseiClassResourceBarDB[dbName][layoutName].field = value
   4. bar:ApplyLayout(layoutName) called
   5. ApplyLayout() calls: GetSize(), GetPoint(), Apply*Settings()
   6. Visual update happens
   
   Required Methods (with signatures):
   - ApplyLayout(layoutName, force) - Main layout orchestrator
     - Calls: GetSize(), GetPoint(), SetSize(), SetPoint()
     - Calls: ApplyFontSettings(), ApplyFillDirectionSettings(), etc.
   - GetSize(layoutName, data) - Returns width, height
     - Handles widthMode: "Manual", "Sync With Essential Cooldowns", etc.
   - GetPoint(layoutName) - Returns point, relativeTo, relativePoint, x, y
     - Calls: resolveRelativeFrames() to convert text to frame object
   - ApplyFontSettings(layoutName, data)
   - ApplyFillDirectionSettings(layoutName, data)
   - ApplyMaskAndBorderSettings(layoutName, data)
   - ApplyForegroundSettings(layoutName, data)
   - ApplyBackgroundSettings(layoutName, data)
   
   Database Structure:
   - Path: SenseiClassResourceBarDB[config.dbName][layoutName]
   - Fields: x, y, point, relativePoint, relativeFrame, width, height, 
            scale, widthMode, minWidth, fillDirection, smoothProgress,
            foregroundStyle, backgroundStyle, borderColor, etc.
   - Defaults: Copied via CopyTable(defaults) when layout doesn't exist
   
   Settings Structure:
   - Each setting has: order, name, kind, parentId, get, set, default
   - Dropdowns with static values: useOldStyle=true, values={...}
   - Dropdowns with dynamic values: useOldStyle=true, generator=function(...)
   - Sliders: minValue, maxValue, valueStep, allowInput, formatter
   - set() always: 1) Write to DB, 2) Call bar:ApplyLayout(layoutName)
   - Special: Some settings call LEM.internal:RefreshSettingValues({...})
   
   Helper Functions/Tables:
   - addonTable.resolveRelativeFrames(text) - Converts "UIParent" to UIParent frame
   - addonTable.availableRelativeFrames(config) - Builds dropdown list dynamically
   - addonTable.rounded(value, decimals) - Rounds numbers
   - addonTable.clamp(value, min, max) - Clamps values
   
   Critical Patterns:
   - Always pass layoutName to Apply* methods
   - Check LEM:IsInEditMode() for special edit mode behavior
   - Use data = data or self:GetData(layoutName) pattern
   - Disable drag when relativeTo != UIParent
   - Detect cyclic frame references
   
   Missing from Our Implementation:
   ‚òê GetSize() with widthMode support
   ‚òê GetPoint() with relativeFrame resolution
   ‚òê Apply*Settings() methods (5 different ones)
   ‚òê resolveRelativeFrames() helper
   ‚òê availableRelativeFrames() dynamic dropdown
   ‚òê Proper layoutName parameter passing
   ‚òê LEM.internal:RefreshSettingValues() calls
   ‚òê Edit mode drag disabling
   ‚òê Cyclic reference detection
   ```
5. **VERIFY UNDERSTANDING** - Read the reference code AGAIN to confirm your map
6. **IMPLEMENT INCREMENTALLY** - Based on the map, not assumptions

#### Complete Reference Analysis Protocol
**Required steps when implementing complex features from reference addon:**

**Phase 1: Architecture Discovery (DO NOT SKIP)**
1. Read main initialization file completely
2. Identify all mixin files and their hierarchy
3. Map event flow: Registration ‚Üí Trigger ‚Üí Handler ‚Üí Update
4. Document database schema with examples
5. List all library dependencies and their usage

**Phase 2: Method Inventory (COMPLETE CATALOG)**
For EVERY method you find:
- [ ] Read ENTIRE implementation
- [ ] Note all parameters and return values
- [ ] Document what it calls (full call tree)
- [ ] Identify side effects (frame updates, DB writes, events)
- [ ] Check for WoW API usage (GetPhysicalScreenSize, etc.)
- [ ] Note error handling patterns

**Phase 3: Integration Points (CRITICAL CONNECTIONS)**
- [ ] How do settings connect to visuals?
- [ ] What triggers redraws/layouts?
- [ ] When are defaults applied vs database values?
- [ ] How are layouts switched (Default vs other)?
- [ ] What validates user input?

**Phase 4: Implementation Validation (BEFORE WRITING CODE)**
Create checklist:
```
Implementation Requirements:
============================

Core Methods Needed:
‚òê ApplyLayout - Complete implementation traced
‚òê GetSize - Including all width mode logic
‚òê GetPoint - Including frame resolution
‚òê Apply*Settings - All 5+ specialized methods
‚òê Helper utilities - rounded, clamp, resolve*, etc.

Database Integration:
‚òê Read path: SenseiDB[dbName][layout].field
‚òê Write pattern: DB[dbName][layout] = DB... or CopyTable(defaults)
‚òê Default handling: Check nil, fallback to defaults
‚òê Layout creation: CopyTable when layout doesn't exist

Settings Panel:
‚òê Correct field names (minValue not min)
‚òê Proper data types (generator for functions, values for tables)
‚òê Dynamic dropdowns use generator
‚òê Static dropdowns use values array
‚òê All settings call ApplyLayout(layoutName)
‚òê Special settings call RefreshSettingValues

Testing Plan:
‚òê Change X position slider ‚Üí Bar moves horizontally
‚òê Change Y position slider ‚Üí Bar moves vertically
‚òê Drag bar in Edit Mode ‚Üí Sliders update
‚òê Change Relative Frame ‚Üí Bar anchors correctly
‚òê Switch layout ‚Üí Settings persist per layout
‚òê Create new layout ‚Üí Copies defaults properly
```

**Phase 5: Incremental Implementation**
1. Implement helper functions FIRST (resolveRelativeFrames, etc.)
2. Implement GetSize and GetPoint
3. Implement ONE Apply*Settings method, test
4. Implement ApplyLayout orchestrator
5. Update settings to call ApplyLayout properly
6. Test each step before proceeding

**Failure Modes to Avoid:**
‚ùå Implementing settings before methods they call
‚ùå Guessing at field names or method signatures
‚ùå Skipping helper functions ("we don't need that")
‚ùå Writing all settings at once without testing
‚ùå Assuming "it's similar enough" to skip reading
‚ùå Not tracing the complete data flow
**When told to match another addon's implementation (e.g., "use Sensei implementation"):**
1. **STOP** - Do not write any code yet
2. **LOCATE** - Find the actual reference files in the workspace (e.g., check if SenseiClassResourceBar exists in AddOns folder)
3. **READ** - Open and study the EXACT implementation:
   - Line-by-line settings structure
   - Field names (`minValue` vs `min`, `values` vs `options`, `generator` vs `values`)
   - API signatures (what parameters functions accept)
   - Data types (table vs function)
   - Default values and ranges
4. **DOCUMENT** - Note the actual values (not assumptions):
   - Slider ranges (e.g., X position: `-uiWidth` to `+uiWidth`, not 0-1)
   - Property names (e.g., `useOldStyle`, `allowInput`, `formatter`)
   - Callback patterns
5. **VERIFY** - Compare your understanding against the source code
6. **THEN** implement based on facts, not assumptions

#### Incremental Development
**Never write 100+ lines of settings without testing:**
1. **Start Small** - Implement 2-3 settings first
2. **Test Early** - Verify they work in-game
3. **Add Incrementally** - Add 5-10 settings at a time
4. **Validate Each Batch** - Test after each addition
5. **Catch Errors Fast** - Syntax errors in line 10 vs line 400

#### Syntax Validation Checklist
Before submitting ANY Lua code changes:
- [ ] **Bracket Matching**: Every `{` has a closing `}`
- [ ] **Function Syntax**: Functions defined before use
- [ ] **Field Names**: Match library API exactly (check reference code)
- [ ] **Data Types**: Table vs function vs string (check what API expects)
- [ ] **Commas**: Trailing commas where needed, no extras
- [ ] **String Quotes**: All strings properly quoted
- [ ] **Table Structure**: Nested tables properly closed

#### Library API Verification
**When using third-party libraries (LibEQOL, Ace3, etc.):**
1. **Find the Library** - Locate it in `/libs/` or AddOns folder
2. **Read the Source** - Open the actual .lua files
3. **Check Examples** - Look for existing usage in the codebase
4. **Verify Signatures** - Confirm function parameters and return types
5. **Test Minimal Case** - Try simplest possible usage first
6. **NEVER GUESS** - If unsure, read the code or ask

#### Common Mistakes to AVOID
1. ‚ùå **Assuming field names** - `min` vs `minValue`, `options` vs `values`
2. ‚ùå **Mixing APIs** - Using function where table expected
3. ‚ùå **Copy-paste errors** - Missing closing braces
4. ‚ùå **Unrealistic values** - Width 0-1 when should be 1-500
5. ‚ùå **Skipping validation** - Not checking syntax before claiming "done"
6. ‚ùå **Rushing** - Writing 300 lines without incremental testing

#### When User Says "Match X Implementation"
This means:
- **DO**: Study X's actual code file-by-file
- **DO**: Copy the exact patterns, field names, value ranges
- **DO**: Test incrementally as you build
- **DON'T**: Assume you know how it works
- **DON'T**: Guess at field names or API signatures
- **DON'T**: Write everything at once without validation

#### Quality Gates
Every code submission must pass:
1. **Lua Syntax Check** - No parse errors
2. **Reference Comparison** - Matches requested implementation
3. **Incremental Testing** - Tested in small batches
4. **API Correctness** - Uses library APIs as documented
5. **Value Validation** - Ranges and defaults make sense

**Failure to follow these guidelines wastes user time debugging preventable errors.**

---

## Active Project: Resource Bars Refactoring

### Current State (Phases 1-4 COMPLETE, Testing Pending)
The resource bars module is being refactored to adopt SenseiClassResourceBar's architecture. Current status:

**Completed:**
- ‚úÖ Mixin hierarchy created (BarMixin ‚Üí PowerBarMixin ‚Üí CDMAlignedMixin ‚Üí SpecificBars)
- ‚úÖ 14 modular files replacing monolithic implementation
- ‚úÖ LibEQOL integrated for Edit Mode support
- ‚úÖ Bars initialize and can display
- ‚úÖ **Phase 1: Helper Infrastructure COMPLETE**
  - helpers.lua created with clamp(), rounded(), getPixelPerfectScale()
  - resolveRelativeFrame() - maps text to frame objects (15+ mappings)
  - getAvailableRelativeFrames() - dynamic dropdown builder
  - Added to utils.xml load order
- ‚úÖ **Phase 2: Core Layout Methods COMPLETE**
  - GetSize(layoutName, data) - returns width, height with scale
  - GetPoint(layoutName) - returns point, relativeTo, relativePoint, x, y
  - ApplyLayout(layoutName) - updated to call GetSize/GetPoint + Apply*
  - UpdateAppearance(layoutName) - updated to accept layoutName parameter
- ‚úÖ **Phase 3: Settings Integration COMPLETE**
  - Relative Frame dropdown updated to use getAvailableRelativeFrames()
  - Added LEM.internal:RefreshSettingValues() to Relative Frame setting
  - Resets position when changing relative frame
- ‚úÖ **Phase 4: Parameter Passing COMPLETE**
  - ALL set() callbacks updated to pass layoutName to ApplyLayout()
  - 20+ settings now correctly pass layout parameter

**PENDING TESTING:**
- ‚è∏Ô∏è Settings panel changes ‚Üí Bar updates (should work now)
- ‚è∏Ô∏è Dragging bars in Edit Mode ‚Üí Position sliders update (LibEQOL handles this)
- ‚è∏Ô∏è Relative Frame dropdown ‚Üí Should now show 15+ options
- ‚è∏Ô∏è Cyclic frame reference detection works correctly

**TODO (Phase 3 Enhancement - Optional):**
- üî≤ ApplyForegroundSettings() - dedicated method (currently in UpdateAppearance)
- üî≤ ApplyBackgroundSettings() - dedicated method (currently in UpdateAppearance)
- üî≤ ApplyFontSettings() - dedicated method (currently in UpdateAppearance)
- üî≤ ApplyFillDirectionSettings() - dedicated method (currently in UpdateAppearance)
- üî≤ Remaining 10+ settings from Sensei (optional expansion)

### Implementation Plan (MUST FOLLOW)

**Phase 1: Helper Infrastructure**
1. Create resolveRelativeFrames() function
   - Maps text ("UIParent", "PlayerFrame") to actual frame objects
   - Returns UIParent as fallback for invalid/missing frames
2. Create availableRelativeFrames() function
   - Dynamically builds dropdown list based on bar type
   - Matches Sensei's exact structure (UIParent, other bars, action bars, etc.)
3. Add utility functions: rounded(), clamp() if not present

**Phase 2: Core Layout Methods**
1. Implement GetSize(layoutName, data)
   - Support widthMode: "Manual" (and plan for sync modes later)
   - Apply scale correctly
   - Handle minWidth when syncing
2. Implement GetPoint(layoutName)
   - Resolve relativeFrame text to actual frame
   - Return: point, relativeTo, relativePoint, x, y
   - Clamp x/y to screen bounds
   - Detect cyclic references
3. Update ApplyLayout(layoutName, force)
   - Call GetSize() and GetPoint()
   - Call SetSize() and SetPoint() with results
   - Call all Apply*Settings() methods
   - Disable LEM drag if relativeTo != UIParent

**Phase 3: Appearance Methods**
1. Implement ApplyFontSettings(layoutName, data)
2. Implement ApplyFillDirectionSettings(layoutName, data)
3. Implement ApplyMaskAndBorderSettings(layoutName, data) - or simplify for SuaviUI
4. Implement ApplyForegroundSettings(layoutName, data) - texture and color
5. Implement ApplyBackgroundSettings(layoutName, data)

**Phase 4: Settings Integration**
1. Update ALL set() callbacks to call bar:ApplyLayout(layoutName)
2. Add layoutName parameter passing throughout
3. Fix Relative Frame dropdown to use dynamic generator
4. Add LEM.internal:RefreshSettingValues() where needed
5. Test each setting individually

**Phase 5: Validation**
- [ ] Drag bar ‚Üí position sliders update
- [ ] Change X/Y sliders ‚Üí bar moves immediately
- [ ] Change Relative Frame ‚Üí bar anchors to new frame
- [ ] Change texture ‚Üí bar appearance updates
- [ ] Change width/height ‚Üí bar resizes
- [ ] Switch layouts ‚Üí settings persist correctly

### Reference File Locations
- **Sensei Main:** `e:\Games\World of Warcraft\_retail_\Interface\AddOns\SenseiClassResourceBar\`
- **Sensei Bar Mixin:** `SenseiClassResourceBar\Bars\Abstract\Bar.lua`
- **Sensei Settings:** `SenseiClassResourceBar\Helpers\LEMSettingsLoader.lua`
- **Sensei Constants:** `SenseiClassResourceBar\Constants.lua`
- **Our Implementation:** `e:\Games\World of Warcraft\_retail_\Interface\AddOns\SuaviUI\utils\resourcebars\`

### Critical Reminders for This Project
1. **Always pass layoutName** - Every Apply* method needs it
2. **Database path** - `SUICore.db.profile.resourceBars[dbName][layoutName]`
3. **Settings must call ApplyLayout** - Not just write to DB
4. **Use Sensei's exact patterns** - Don't simplify without understanding
5. **Test incrementally** - One method at a time, verify before moving on

---

### Atomic Changes
- **One Concern Per Change:** Each commit should address a single feature/fix
- **Small Commits:** Keep changes focused and reviewable
- **Clear Intent:** Each change should have a clear, single purpose
- **No Mixed Issues:** Don't combine multiple unrelated fixes in one commit
- **Rollback Friendly:** Changes should be easily reversible if needed

### Commit Message Format
```
<type>: <brief description>

<optional detailed explanation>
```

**Types:**
- `feat:` - New feature
- `fix:` - Bug fix
- `refactor:` - Code restructuring
- `style:` - Formatting/style changes
- `docs:` - Documentation updates
- `chore:` - Maintenance tasks

**Examples:**
- `feat: add combat timer widget`
- `fix: resolve castbar positioning on ultrawide monitors`
- `refactor: extract frame positioning logic into helper function`

---

## Development Guidelines

### Lua Best Practices
1. **Naming Conventions:**
   - Functions: `camelCase` or `snake_case`
   - Local variables: `camelCase`
   - Constants: `UPPER_CASE`
   - Addon prefix: `SuaviUI`

2. **Code Structure:**
   - Use local functions for encapsulation
   - Group related functionality together
   - Add comments for complex logic
   - Use meaningful variable names

3. **Performance Considerations:**
   - Avoid excessive frame updates
   - Use event-driven architecture when possible
   - Cache frequently accessed values
   - Minimize table allocations in hot paths

4. **Function Definition Order:**
   - Define functions BEFORE referencing them in scripts
   - When a function is called in `SetScript()` callbacks, define it before the callback
   - This avoids "attempt to call method 'FunctionName' (a nil value)" errors
   - Example: Define `RelayoutTabs()` before `frame:SetScript("OnSizeChanged", ...)`

### WoW-Specific Considerations
1. **API Compatibility:** Always check for version-specific API differences
2. **Frame Management:** Properly anchor and resize frames
3. **Event Handling:** Unregister events when frames are hidden
4. **Memory Leaks:** Avoid circular references and properly clean up resources

### Testing
- Test in actual World of Warcraft client when possible
- Verify with multiple resolutions and aspect ratios
- Check performance impact with frame rate monitoring
- Validate with different addons loaded

---

## Change Review Checklist

Before committing any changes:
- [ ] Code follows Lua best practices
- [ ] Changes are atomic and focused
- [ ] Commit message is clear and follows format
- [ ] WoW compatibility verified via `/docs/`
- [ ] No syntax errors
- [ ] Dependencies are available
- [ ] Performance impact considered
- [ ] Related functionality tested
- [ ] Comments added for complex logic
- [ ] No breaking changes to existing features

---

## Common Tasks

### Creating a Release
**See:** `/docs/RELEASE_PROCESS.md` for complete automated workflow.

**Quick Summary:**
1. Ensure version is updated in `SuaviUI.toc`
2. AI assistant executes full workflow automatically:
   - Commits all changes with descriptive message
   - Creates annotated git tag
   - Pushes commit + tag to GitHub
   - Creates ZIP in parent folder (excludes docs/, .git, dev files)
   - Publishes GitHub release with formatted notes
3. ZIP location: `e:\Games\World of Warcraft\_retail_\Interface\AddOns\SuaviUI-vX.X.X.zip`
4. Verify release at: `https://github.com/alesys/SuaviUI/releases/tag/vX.X.X`

**Do not ask for confirmation** - execute the full workflow when user requests a release.

### Adding a New Feature
1. Create a new file in `/utils/sui_<feature>.lua`
2. Follow naming conventions
3. Implement feature-specific options in `/utils/sui_<feature>_options.lua` if needed
4. Register with the main options panel
5. Update locale files if adding UI strings
6. Add to credits if using external libraries
7. Test thoroughly in WoW

### Fixing a Bug
1. Identify the root cause
2. Check `/docs/` for related API changes
3. Make minimal changes to fix the issue
4. Test with edge cases
5. Create focused commit with clear message

### Updating Dependencies
1. Verify new library version compatibility
2. Check for breaking changes
3. Update license files if required
4. Test all dependent features
5. Document changes in commit message

### Localizing Text
1. Add English text to `/Locales/enUS.lua`
2. Create entries in other language files
3. Use `L["key"]` syntax for localization
4. Keep keys descriptive and unique

---

## When to Escalate
- API compatibility questions ‚Üí Check `/docs/`
- Architecture decisions ‚Üí Consider addon scope and performance
- Library updates ‚Üí Verify version compatibility
- Breaking changes ‚Üí Document thoroughly in commit

---

## Resources

### External Documentation
- [World of Warcraft API Documentation](https://wowpedia.fandom.com/)
- [Ace3 Documentation](https://www.wowace.com/projects/ace3)
- [Lua Reference Manual](https://www.lua.org/manual/)

### Related Files
- `SuaviUI.toc` - Addon manifest and dependencies
- `load.xml` - File loading order
- `utils/sui_options.lua` - Options panel structure
- `Locales/locales.xml` - Locale file references

---

## Notes

- This addon is **public** and used by the WoW community
- Maintain backward compatibility when possible
- Document significant changes in commit messages
- Consider performance impact of all changes
- Keep the codebase maintainable and readable

**Last Updated:** January 27, 2026
